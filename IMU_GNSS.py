# -*- coding: utf-8 -*-
"""IMU/GNSS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rVjNhFPyO_n6kzCBeFlUMAknlEF_UOad
"""

import os
import math
import time
import glob
import scipy

import numpy as np
import sympy as sp
import pandas as pd

from datetime import datetime
from matplotlib import pyplot as plt

from ExtendedKalmanFilter import EKF

def lat_lon_converter(df:pd.DataFrame):
    a = 6378137      # semi-major axis of the Earth
    f = 1/298.257223 # flattening
    b = a*(1-f)      # semi-minor axis of the Earth
    e = np.sqrt(1 - (b/a)**2) # eccentricity

    lon = np.array(df['lon'])
    lat = np.array(df['lat'])
    alt = np.array(df['alt'])

    N = a / np.sqrt(1 - (e*np.sin(np.deg2rad(lat)))**2)
    x = (N + alt) * np.cos(np.deg2rad(lat)) * np.cos(np.deg2rad(lon))
    y = (N + alt) * np.cos(np.deg2rad(lat)) * np.sin(np.deg2rad(lon))
    z = (b**2/a**2 * N + alt) * np.sin(np.deg2rad(lat))

    # x = alt * np.cos(np.deg2rad(lat)) * np.cos(np.deg2rad(lon))
    # y = alt * np.cos(np.deg2rad(lat)) * np.sin(np.deg2rad(lon))
    # z = alt * np.sin(np.deg2rad(lat))

    # subtract the initial position from each row
    x -= x[0]
    y -= y[0]
    z -= z[0]

    # update the dataframe with the new values
    df['x'] = x
    df['y'] = y
    df['z'] = z

    return df

path = "pd_GPS_hepsi.csv"
df = pd.read_csv(path)

df.ts = pd.to_datetime(df.ts, format='%H:%M:%S.%f')
time_stamps = df.ts
diff_list = [(time_stamps[i] - time_stamps[i-1]).total_seconds() for i in range(1, len(time_stamps))]
diff_list.insert(0, math.nan)
df.insert(0, "delta_t", diff_list)

df = lat_lon_converter(df)

necessary_columns = ["delta_t", "x", "y", "z", "vx", "vy", "vz", "ax", "ay", "az", "wx", "wy", "wz"]
data = df.loc[:, necessary_columns]

data = data.iloc[::10]
data.shape

output = []

# Initialize the ExtendedKalmanFilter object with the initial state and covariance, process noise covariance,
# measurement noise covariance, and time step
x0 = np.array(data.iloc[0][['x', 'y', 'z', 'vx', 'vy', 'vz']]) 
P0 = np.eye(6) * 0.01
Q = np.eye(6) * 0.001
R = np.eye(6) * 0.1

# symbol definitions
x, y, z = sp.symbols('x y z')
vx, vy, vz = sp.symbols('vx vy vz')
wx, wy, wz = sp.symbols('wx wy wz')
ax, ay, az = sp.symbols('ax ay az')
dt = sp.symbols("dt")

state = sp.Matrix(['x', 'y', 'z', 'vx', 'vy', 'vz'])
control = sp.Matrix(['ax', 'ay', 'az', 'wx', 'wy', 'wz'])

f = sp.Matrix([x + dt*vx + 0.5*dt*dt*(ax - wy*vz + wz*vy),
               y + dt*vy + 0.5*dt*dt*(ay + wx*vz - wz*vx),
               z + dt*vz + 0.5*dt*dt*(az - wx*vy + wy*vx),
               vx + dt*(ax - wy*vz + wz*vy),
               vy + dt*(ay + wx*vz - wz*vx),
               vz + dt*(az - wx*vy + wy*vx)])

h = sp.Matrix(state)

ekf = EKF(x0, P0, Q, R, state, control, f, h)

# Run the Extended Kalman Filter on the state and control vectors in the DataFrame
t1 = time.time()
for i in range(1, len(data)):
    
    # Get the control input and measurement vector from the DataFrame
    u = np.array(data.iloc[i][['ax', 'ay', 'az', 'wx', 'wy', 'wz']]).reshape(-1, 1)
    z = np.array(data.iloc[i][['x', 'y', 'z', 'vx', 'vy', 'vz']]).reshape(-1, 1) + np.random.normal(0,1, size=(6,1))

    # Run the forward step of the Extended Kalman Filter with the control input and measurement vector
    ekf.predict(u, dt_n = data.iloc[i,0])
    ekf.update(z)

    output.append(ekf.x[:3])
t2 = time.time()
print(f"Elapsed time for calculating {len(df)} samples is {t2-t1}")
# Print the current state estimate and state covariance
# print(f"State estimate at time step {i}: {ekf.x}")
# print(f"State covariance at time step {i}: {ekf.P}")

plotting_type = "3D"

if plotting_type == "3D":
    # Extract the x, y, and z positions from the list of lists
    x_positions = [pos[0] for pos in output]
    y_positions = [pos[1] for pos in output]
    z_positions = [pos[2] for pos in output]

    # Create a 3D scatter plot of the car's positions
    fig = plt.figure(figsize=(10,10))
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(x_positions, y_positions, z_positions)
    ax.scatter(data["x"], data["y"], data["z"])
    # Set the labels for the x, y, and z axes
    ax.set_xlabel('X Position (m)')
    ax.set_ylabel('Y Position (m)')
    ax.set_zlabel('Z Position (m)')

    ax.legend(["estimation", "truth"])
    # Show the plot
    plt.show()

if plotting_type == "2D":
    # Extract the x, y, and z positions from the list of lists
    x_positions = [pos[0] for pos in output]
    y_positions = [pos[1] for pos in output]

    # Create a 3D scatter plot of the car's positions
    fig = plt.figure(figsize=(10,10))
    ax = fig.add_subplot(111)
    ax.scatter(x_positions, y_positions)
    ax.scatter(data["x"], data["y"])
    # Set the labels for the x and y axes
    ax.set_xlabel('X Position (m)')
    ax.set_ylabel('Y Position (m)')

    ax.legend(["estimation", "truth"])
    # Show the plot
    plt.show()